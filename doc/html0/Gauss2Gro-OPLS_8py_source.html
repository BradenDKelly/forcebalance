<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ForceBalance: forcebalance/bin/Gauss2Gro-OPLS.py Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="ForceBalanceLogo_sm.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ForceBalance
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Automated optimization of force fields and empirical potentials</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/roadmap.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="api/namespaces.html"><span>API</span></a></li>
      <li><a href="installation.html"><span>Installation</span></a></li>
      <li><a href="usage.html"><span>Usage</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="glossary.html"><span>Glossary</span></a></li>
      <li><a href="todo.html"><span>To-Do&#160;List</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">forcebalance/bin/Gauss2Gro-OPLS.py</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">#!/usr/bin/env python</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="keyword">from</span> numpy <span class="keyword">import</span> *
<a name="l00004"></a>00004 <span class="keyword">import</span> os
<a name="l00005"></a>00005 <span class="keyword">from</span> sys <span class="keyword">import</span> argv,exit
<a name="l00006"></a>00006 <span class="keyword">import</span> forcebalance
<a name="l00007"></a>00007 <span class="keyword">from</span> forcebalance.PT <span class="keyword">import</span> PeriodicTable
<a name="l00008"></a>00008 <span class="keyword">from</span> forcebalance.nifty <span class="keyword">import</span> isint, printcool
<a name="l00009"></a>00009 <span class="keyword">import</span> getopt
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 opts,args = getopt.getopt(argv[1:],<span class="stringliteral">&#39;h&#39;</span>)
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 AutoH = <span class="keyword">False</span>
<a name="l00014"></a>00014 <span class="keywordflow">for</span> o,a <span class="keywordflow">in</span> opts:
<a name="l00015"></a>00015     argv.remove(o)
<a name="l00016"></a>00016     <span class="keywordflow">if</span> o == <span class="stringliteral">&quot;-h&quot;</span>:
<a name="l00017"></a>00017         AutoH = <span class="keyword">True</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 Alphabet = list(map(chr, range(65, 91)))
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 printcool(<span class="stringliteral">&quot; Welcome to Lee-Ping&#39;s Force Field Generator --- &quot;</span>)
<a name="l00022"></a>00022 <span class="keywordflow">print</span> <span class="stringliteral">&quot; This script attempts to generate an OPLS force field &quot;</span>
<a name="l00023"></a>00023 <span class="keywordflow">print</span> <span class="stringliteral">&quot; from any Gaussian input file.  Here&#39;s how it works.  &quot;</span>
<a name="l00024"></a>00024 <span class="keywordflow">print</span> <span class="stringliteral">&quot; 1.  Define your atom types.                          &quot;</span>
<a name="l00025"></a>00025 <span class="keywordflow">print</span> <span class="stringliteral">&quot; 2.  Define corresponding OPLS atom types.            &quot;</span>
<a name="l00026"></a>00026 <span class="keywordflow">print</span> <span class="stringliteral">&quot;     If there is no corresponding OPLS type, then you &quot;</span>
<a name="l00027"></a>00027 <span class="keywordflow">print</span> <span class="stringliteral">&quot;     must define your own.&quot;</span>
<a name="l00028"></a>00028 <span class="keywordflow">print</span> <span class="stringliteral">&quot; 3.  Select or input bonding parameters.              &quot;</span>
<a name="l00029"></a>00029 <span class="keywordflow">print</span> <span class="stringliteral">&quot;     If you selected OPLS atom types, then the program&quot;</span>
<a name="l00030"></a>00030 <span class="keywordflow">print</span> <span class="stringliteral">&quot;     will attempt to recommend parameters for you.    &quot;</span>
<a name="l00031"></a>00031 <span class="keywordflow">print</span> <span class="stringliteral">&quot; 4.  Finished: GRO and ITP files will be generated.   &quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00034"></a>00034 <span class="stringliteral">gauss2gro-OPLS.py is an automatic force field maker, which builds a</span>
<a name="l00035"></a>00035 <span class="stringliteral">force field from a molecular topology (in Gaussian .com format) and</span>
<a name="l00036"></a>00036 <span class="stringliteral">fills in parameters automatically from OPLS-AA.  This is probably the</span>
<a name="l00037"></a>00037 <span class="stringliteral">most complicated script I&#39;ve written next to ForceBalance.  To avoid</span>
<a name="l00038"></a>00038 <span class="stringliteral">confusion, this script DOES NOT do parameter optimization, it just</span>
<a name="l00039"></a>00039 <span class="stringliteral">generates a force field from the OPLS parameter libraries for pretty</span>
<a name="l00040"></a>00040 <span class="stringliteral">much any molecule you want.  You still have to fill in parameters by</span>
<a name="l00041"></a>00041 <span class="stringliteral">hand for any gaps in OPLS (which are plenty).</span>
<a name="l00042"></a>00042 <span class="stringliteral"> </span>
<a name="l00043"></a>00043 <span class="stringliteral">Here&#39;s how it works.</span>
<a name="l00044"></a>00044 <span class="stringliteral"></span>
<a name="l00045"></a>00045 <span class="stringliteral">As an input, we must have a Gaussian .com file with connectivity.</span>
<a name="l00046"></a>00046 <span class="stringliteral">Usually, it&#39;s easiest to open a .com file with GaussView and resave</span>
<a name="l00047"></a>00047 <span class="stringliteral">it, making sure that geom=connectivity is in the first line.</span>
<a name="l00048"></a>00048 <span class="stringliteral"></span>
<a name="l00049"></a>00049 <span class="stringliteral">To enable automated atom-type definition (very helpful if you want to</span>
<a name="l00050"></a>00050 <span class="stringliteral">follow OPLS &#39;standards&#39;,) you need to do either of the following:</span>
<a name="l00051"></a>00051 <span class="stringliteral"></span>
<a name="l00052"></a>00052 <span class="stringliteral">OPTION 1 (recommended)</span>
<a name="l00053"></a>00053 <span class="stringliteral">In the Gaussian .com file, after every atom name, type in &#39;!opls_xxx&#39; </span>
<a name="l00054"></a>00054 <span class="stringliteral">where opls_xxx is the standard opls atomtype </span>
<a name="l00055"></a>00055 <span class="stringliteral">(look it up using &#39;explain-opls.py&#39; C for carbon).</span>
<a name="l00056"></a>00056 <span class="stringliteral"></span>
<a name="l00057"></a>00057 <span class="stringliteral">OPTION 2:</span>
<a name="l00058"></a>00058 <span class="stringliteral">In the Gaussian .com file, after every atom name, type in &#39;!atom_type&#39; </span>
<a name="l00059"></a>00059 <span class="stringliteral">where atom_type is an atom type of your choosing.</span>
<a name="l00060"></a>00060 <span class="stringliteral">Somewhere else in the Gaussian file (preferably after the first line</span>
<a name="l00061"></a>00061 <span class="stringliteral">and before the xyz coordinates), type in &#39;! atom_type opls_xxx&#39; to</span>
<a name="l00062"></a>00062 <span class="stringliteral">identify that atom type with the OPLS parameters.</span>
<a name="l00063"></a>00063 <span class="stringliteral"></span>
<a name="l00064"></a>00064 <span class="stringliteral">When the program is run, the first thing it does is try to get the</span>
<a name="l00065"></a>00065 <span class="stringliteral">OPLS atom types.  You can assign atom types using one of the two</span>
<a name="l00066"></a>00066 <span class="stringliteral">options above, in which case it will get the whole list automatically.</span>
<a name="l00067"></a>00067 <span class="stringliteral">Otherwise, you can define atom types by element, or more specifically</span>
<a name="l00068"></a>00068 <span class="stringliteral">by element + nearest neighbors.  In the latter case, you will be asked</span>
<a name="l00069"></a>00069 <span class="stringliteral">to pick OPLS atom types manually, or enter your own nonbonded</span>
<a name="l00070"></a>00070 <span class="stringliteral">parameters.  Picking OPLS atom types has the advantage that the bonded</span>
<a name="l00071"></a>00071 <span class="stringliteral">parameters will be automatically chosen for you.</span>
<a name="l00072"></a>00072 <span class="stringliteral"></span>
<a name="l00073"></a>00073 <span class="stringliteral">Once the atom types are chosen, the program will sum up all of the</span>
<a name="l00074"></a>00074 <span class="stringliteral">atomic charges.  Because a simulation generally likes to have an</span>
<a name="l00075"></a>00075 <span class="stringliteral">integer (usually zero) total charge, you will be given the option to</span>
<a name="l00076"></a>00076 <span class="stringliteral">add a constant charge to every atom in order to make the overall</span>
<a name="l00077"></a>00077 <span class="stringliteral">molecule neutral.  Finally, there is a fine-tuning step which allows</span>
<a name="l00078"></a>00078 <span class="stringliteral">you to add small amounts to the charge so that it&#39;s _exactly_ zero,</span>
<a name="l00079"></a>00079 <span class="stringliteral">despite the finite floating-point precision of the force field file.</span>
<a name="l00080"></a>00080 <span class="stringliteral"></span>
<a name="l00081"></a>00081 <span class="stringliteral">The next thing the program does is to automatically parameterize all</span>
<a name="l00082"></a>00082 <span class="stringliteral">of the detected bonds, angles, and dihedral types.  To do this, there</span>
<a name="l00083"></a>00083 <span class="stringliteral">is a rather complicated set of lists.  Basically, in GROMACS there</span>
<a name="l00084"></a>00084 <span class="stringliteral">each atom has several types associated with it: the &#39;element&#39; (e.g. C</span>
<a name="l00085"></a>00085 <span class="stringliteral">= 6), the &#39;base type&#39;, the &#39;OPLS type&#39;, the &#39;bonded type&#39;, and the</span>
<a name="l00086"></a>00086 <span class="stringliteral">&#39;OPLS nickname&#39; defined in ffoplsaanb.itp.  In orthodox OPLS, the base</span>
<a name="l00087"></a>00087 <span class="stringliteral">type starts with &#39;opls_&#39;, and is the same as the OPLS type; the bonded</span>
<a name="l00088"></a>00088 <span class="stringliteral">atom type (e.g. &#39;CA&#39;, &#39;C_2&#39; etc). and the OPLS nickname are the same.</span>
<a name="l00089"></a>00089 <span class="stringliteral">In custom force fields, the base type, and the bonded atom type are</span>
<a name="l00090"></a>00090 <span class="stringliteral">the same, but the OPLS type and the OPLS nickname are different.  The</span>
<a name="l00091"></a>00091 <span class="stringliteral">OPLS type and nickname are essential for pulling the bonded parameters</span>
<a name="l00092"></a>00092 <span class="stringliteral">out of the ffoplsaabon.itp file.  Thus, all four lists are important.</span>
<a name="l00093"></a>00093 <span class="stringliteral"></span>
<a name="l00094"></a>00094 <span class="stringliteral">awkx gives a list of atoms and Cartesian coordinates, much like the</span>
<a name="l00095"></a>00095 <span class="stringliteral">data in the xyz file.  awkc gives a list of the bonds at the end of</span>
<a name="l00096"></a>00096 <span class="stringliteral">the Gaussian .com file.  awkpd gives a list of OPLS atom types which</span>
<a name="l00097"></a>00097 <span class="stringliteral">correspond to the custom atom types, useful only in OPTION 2 above.</span>
<a name="l00098"></a>00098 <span class="stringliteral">awkat gives a N-length list of cutom atom types or OPLS atom types,</span>
<a name="l00099"></a>00099 <span class="stringliteral">depending on what the user has defined.</span>
<a name="l00100"></a>00100 <span class="stringliteral"></span>
<a name="l00101"></a>00101 <span class="stringliteral">Below are explanations of names of variables.</span>
<a name="l00102"></a>00102 <span class="stringliteral"></span>
<a name="l00103"></a>00103 <span class="stringliteral">oplsatoms, oplsnb, oplsbon are OPLS force field files, which are</span>
<a name="l00104"></a>00104 <span class="stringliteral">essential to the working of this script.  They MUST point to the</span>
<a name="l00105"></a>00105 <span class="stringliteral">locations of these files for automatic parameterization.</span>
<a name="l00106"></a>00106 <span class="stringliteral">OPLSExplanations is a dictionary of strings from ffoplsaa.atp of &#39;OPLS</span>
<a name="l00107"></a>00107 <span class="stringliteral">type&#39;:</span>
<a name="l00108"></a>00108 <span class="stringliteral">E is a N-length list of elements.</span>
<a name="l00109"></a>00109 <span class="stringliteral">R is a 3N-length array of Cartesian coordinates.</span>
<a name="l00110"></a>00110 <span class="stringliteral">T is a N-length list of base types.</span>
<a name="l00111"></a>00111 <span class="stringliteral">sbonds is a N-length list of lists, where the i-th entry contains all</span>
<a name="l00112"></a>00112 <span class="stringliteral"> of the atoms j bonded to atom i.  It&#39;s the same as abonds (from the</span>
<a name="l00113"></a>00113 <span class="stringliteral"> Gaussian file), except that bonds are bidirectional (i.e. the j-h</span>
<a name="l00114"></a>00114 <span class="stringliteral"> entry still lists i as a bonded atom, even if j&gt;i).</span>
<a name="l00115"></a>00115 <span class="stringliteral">M is a dictionary of &#39;base type&#39; : [atomic number, atomic mass, sigma,</span>
<a name="l00116"></a>00116 <span class="stringliteral"> epsilon].  As you can see, each base type has its own nonbonded</span>
<a name="l00117"></a>00117 <span class="stringliteral"> parameters.</span>
<a name="l00118"></a>00118 <span class="stringliteral">BAT is a dictionary of &#39;base type&#39;: &#39;bonded type&#39;</span>
<a name="l00119"></a>00119 <span class="stringliteral">TEDict is a dictionary of &#39;base type U bonded type&#39;: &#39;element&#39;</span>
<a name="l00120"></a>00120 <span class="stringliteral">OPLSNicks is a dictionary of &#39;bonded type&#39;: &#39;OPLS nickname&#39;</span>
<a name="l00121"></a>00121 <span class="stringliteral">BList, AList, and DList are lists of interactions, which are built by</span>
<a name="l00122"></a>00122 <span class="stringliteral"> searching the topology.  They are printed out in the later part of the</span>
<a name="l00123"></a>00123 <span class="stringliteral"> force field file which lists all of the specific bonded interactions.</span>
<a name="l00124"></a>00124 <span class="stringliteral">BTypeList, ATypeList, and DTypeList are lists of interaction types,</span>
<a name="l00125"></a>00125 <span class="stringliteral"> which are built by searching the topology and enumerating the unique</span>
<a name="l00126"></a>00126 <span class="stringliteral"> combinations of bonds, angles, and dihedrals (in terms of the OPLS</span>
<a name="l00127"></a>00127 <span class="stringliteral"> nicknames).  They enter into the DefineParameters function, which</span>
<a name="l00128"></a>00128 <span class="stringliteral"> returns dictionaries of interaction types ready for printing.</span>
<a name="l00129"></a>00129 <span class="stringliteral">BondTypes, AngleTypes, and DihedralTypes are dictionaries of</span>
<a name="l00130"></a>00130 <span class="stringliteral"> &#39;bonded_type_1.bonded_type_2...&#39; : [InteractionClass,[Bonded</span>
<a name="l00131"></a>00131 <span class="stringliteral"> Parameters]].  These dictionaries are all created in the</span>
<a name="l00132"></a>00132 <span class="stringliteral"> &#39;DefineParameters&#39; function, all enter into the &#39;PrintTypeSection&#39;</span>
<a name="l00133"></a>00133 <span class="stringliteral"> function as the &#39;SectionDict&#39; argument.  OPLS nicknames are separated</span>
<a name="l00134"></a>00134 <span class="stringliteral"> with periods, because OPLS nicknames themselves do not contain</span>
<a name="l00135"></a>00135 <span class="stringliteral"> periods.  For example, a key in DihedralTypes would look like</span>
<a name="l00136"></a>00136 <span class="stringliteral"> &#39;CT.CA_2.CB.C!&#39; and the value would look like [[3],[0.0 1.0 2.0 3.0</span>
<a name="l00137"></a>00137 <span class="stringliteral"> 4.0 5.0]].</span>
<a name="l00138"></a>00138 <span class="stringliteral">AtomTypeCount is a dictionary of &#39;base type&#39; : &#39;number of</span>
<a name="l00139"></a>00139 <span class="stringliteral"> occurrences&#39;, which is used for zeroing out the net charge.</span>
<a name="l00140"></a>00140 <span class="stringliteral">QDict is a dictionary of &#39;base type&#39;: &#39;atomic charge&#39;.  Note that the</span>
<a name="l00141"></a>00141 <span class="stringliteral"> atomic charge is printed out in the atoms section only; currently I</span>
<a name="l00142"></a>00142 <span class="stringliteral"> choose to not print out any charges in the atomtypes section, as they</span>
<a name="l00143"></a>00143 <span class="stringliteral"> are defined in the atoms section anyway..</span>
<a name="l00144"></a>00144 <span class="stringliteral">predict and preatom are used for generating pre-defined atom types.</span>
<a name="l00145"></a>00145 <span class="stringliteral">TDict is only used for generating neighbor-based atom types.</span>
<a name="l00146"></a>00146 <span class="stringliteral"></span>
<a name="l00147"></a>00147 <span class="stringliteral">As of October 2012, this script is a part of ForceBalance.</span>
<a name="l00148"></a>00148 <span class="stringliteral"></span>
<a name="l00149"></a>00149 <span class="stringliteral">All code in this repository is released under the GNU General Public License.</span>
<a name="l00150"></a>00150 <span class="stringliteral"></span>
<a name="l00151"></a>00151 <span class="stringliteral">#===========#</span>
<a name="l00152"></a>00152 <span class="stringliteral">#| License |#</span>
<a name="l00153"></a>00153 <span class="stringliteral">#===========#</span>
<a name="l00154"></a>00154 <span class="stringliteral"></span>
<a name="l00155"></a>00155 <span class="stringliteral">This program is free software: you can redistribute it and/or modify it under</span>
<a name="l00156"></a>00156 <span class="stringliteral">the terms of the GNU General Public License as published by the Free Software</span>
<a name="l00157"></a>00157 <span class="stringliteral">Foundation, either version 3 of the License, or (at your option) any later</span>
<a name="l00158"></a>00158 <span class="stringliteral">version.</span>
<a name="l00159"></a>00159 <span class="stringliteral"></span>
<a name="l00160"></a>00160 <span class="stringliteral">This program is distributed in the hope that it will be useful, but without any</span>
<a name="l00161"></a>00161 <span class="stringliteral">warranty; without even the implied warranty of merchantability or fitness for a</span>
<a name="l00162"></a>00162 <span class="stringliteral">particular purpose.  See the GNU General Public License for more details.</span>
<a name="l00163"></a>00163 <span class="stringliteral"> </span>
<a name="l00164"></a>00164 <span class="stringliteral">You should have received a copy of the GNU General Public License along with</span>
<a name="l00165"></a>00165 <span class="stringliteral">this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00166"></a>00166 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="comment"># Gets the molecule name</span>
<a name="l00169"></a>00169 molname = argv[1][:3].upper()
<a name="l00170"></a>00170 molnametemp = raw_input(<span class="stringliteral">&quot;Enter molecule name (three letters, default %s) &gt;&gt; &quot;</span> % molname)
<a name="l00171"></a>00171 <span class="keywordflow">if</span> len(molnametemp) == 3:
<a name="l00172"></a>00172     molname = molnametemp
<a name="l00173"></a>00173 <span class="keywordflow">else</span>:
<a name="l00174"></a>00174     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Going with the default name (%s)&quot;</span> % molname
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment"># ENHANCED, SUPER-SPECIFIC FILTERS!!!</span>
<a name="l00177"></a>00177 awkx = <span class="stringliteral">&quot;awk -F &#39;!&#39; &#39;{print $1}&#39; %s | awk \&#39;(NF==4 &amp;&amp; $1*1!=$1 &amp;&amp; $2*1==$2 &amp;&amp; $3*1==$3 &amp;&amp; $4*1==$4){print}\&#39; &quot;</span> % argv[1]
<a name="l00178"></a>00178 awkc = <span class="stringliteral">&quot;awk -F &#39;!&#39; &#39;{print $1}&#39; %s | awk \&#39;($1==sprintf(\&quot;%%i\&quot;,$1) &amp;&amp; NF%%2==1){p=1;for(i=1;i&lt;=NF;i++){if(i%%2==0){if($i!=sprintf(\&quot;%%i\&quot;,$i)){p=0}}else{if($i!=$i*1){p=0}}}if(p==1){print}}\&#39;&quot;</span> % argv[1]
<a name="l00179"></a>00179 awkpd = <span class="stringliteral">&quot;grep &#39;!&#39; %s | awk &#39;/ATYPE/ {print $(NF-1),$NF}&#39;&quot;</span> % argv[1]
<a name="l00180"></a>00180 awkat = <span class="stringliteral">&quot;awk \&#39;(NF&gt;=4 &amp;&amp; $1*1!=$1 &amp;&amp; $2*1==$2 &amp;&amp; $3*1==$3 &amp;&amp; $4*1==$4){print}\&#39; %s | awk -F &#39;!&#39; &#39;{if (NF&gt;1) {print $NF}}&#39; | awk &#39;{print $1}&#39;&quot;</span> % argv[1]
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment"># Locations of files</span>
<a name="l00183"></a>00183 datadir = os.path.split(forcebalance.__file__)[0]
<a name="l00184"></a>00184 oplsatoms = os.path.join(datadir,<span class="stringliteral">&#39;data&#39;</span>,<span class="stringliteral">&#39;oplsaa.ff&#39;</span>,<span class="stringliteral">&#39;atomtypes.atp&#39;</span>)
<a name="l00185"></a>00185 oplsnb = os.path.join(datadir,<span class="stringliteral">&#39;data&#39;</span>,<span class="stringliteral">&#39;oplsaa.ff&#39;</span>,<span class="stringliteral">&#39;ffnonbonded.itp&#39;</span>)
<a name="l00186"></a>00186 oplsbon = os.path.join(datadir,<span class="stringliteral">&#39;data&#39;</span>,<span class="stringliteral">&#39;oplsaa.ff&#39;</span>,<span class="stringliteral">&#39;ffbonded.itp&#39;</span>)
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 OPLSExplanations = {}
<a name="l00189"></a>00189 <span class="keywordflow">for</span> line <span class="keywordflow">in</span> os.popen(<span class="stringliteral">&quot;awk &#39;$1 !~ /;/&#39; %s&quot;</span> % oplsatoms).readlines():
<a name="l00190"></a>00190     doc = line.split(<span class="stringliteral">&quot;;&quot;</span>)[1].strip()
<a name="l00191"></a>00191     OPLSExplanations[line.split()[0]] = doc
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="comment"># Gets elements and cartesian coordinates</span>
<a name="l00194"></a>00194 E = [l.split()[0] <span class="keywordflow">for</span> l <span class="keywordflow">in</span> os.popen(awkx)] <span class="comment"># Element list</span>
<a name="l00195"></a>00195 R = array([[float(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> l.split()[1:]] <span class="keywordflow">for</span> l <span class="keywordflow">in</span> os.popen(awkx)])/10 <span class="comment"># Cartesian coordinate list</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment"># Gets list of bonds</span>
<a name="l00198"></a>00198 abonds = [sorted([int(i)-1 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> l.split()[1::2]]) <span class="keywordflow">for</span> l <span class="keywordflow">in</span> os.popen(awkc)]
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment"># Gets lists of pre-defined atom types</span>
<a name="l00201"></a>00201 predict = {}
<a name="l00202"></a>00202 <span class="keywordflow">for</span> l <span class="keywordflow">in</span> os.popen(awkpd):
<a name="l00203"></a>00203     predict[l.split()[0]] = l.split()[1]
<a name="l00204"></a>00204 preatom = [l.strip() <span class="keywordflow">for</span> l <span class="keywordflow">in</span> os.popen(awkat)]
<a name="l00205"></a>00205 <span class="keywordflow">for</span> l <span class="keywordflow">in</span> preatom:
<a name="l00206"></a>00206     <span class="keywordflow">if</span> <span class="stringliteral">&quot;opls_&quot;</span> <span class="keywordflow">in</span> l:
<a name="l00207"></a>00207         predict[l] = l
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment"># Initialize variables</span>
<a name="l00210"></a>00210 sbonds = []
<a name="l00211"></a>00211 T = []
<a name="l00212"></a>00212 BAT = {}
<a name="l00213"></a>00213 TDict = {} <span class="comment"># BONDS: TYPE</span>
<a name="l00214"></a>00214 TEDict = {} <span class="comment"># TYPE: ELEMENT</span>
<a name="l00215"></a>00215 na = len(abonds)
<a name="l00216"></a>00216 M = {}
<a name="l00217"></a>00217 OPLSNicks = {}
<a name="l00218"></a>00218 AtomTypeCount = {}
<a name="l00219"></a>00219 BList = [] <span class="comment"># List of Bonds</span>
<a name="l00220"></a>00220 AList = [] <span class="comment"># List of Angles</span>
<a name="l00221"></a>00221 DList = [] <span class="comment"># List of Dihedrals</span>
<a name="l00222"></a>00222 BTypeList = []
<a name="l00223"></a>00223 ATypeList = []
<a name="l00224"></a>00224 DTypeList = []
<a name="l00225"></a>00225 QDict = {} <span class="comment"># List of Charges</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment"># Alternate angle parameters that kick in if the angle exceeds ThreshAngle.  This part is ugly and might need rewriting.</span>
<a name="l00228"></a>00228 altangles = {<span class="stringliteral">&quot;O.Co.O&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00229"></a>00229              <span class="stringliteral">&quot;O.Co.OA&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00230"></a>00230              <span class="stringliteral">&quot;O.Co.OB&quot;</span>:[[1],[1.3392e+02,5.1575e+01]],
<a name="l00231"></a>00231              <span class="stringliteral">&quot;O.Co.OC&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00232"></a>00232              <span class="stringliteral">&quot;OA.Co.OA&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00233"></a>00233              <span class="stringliteral">&quot;OA.Co.OB&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00234"></a>00234              <span class="stringliteral">&quot;OA.Co.OC&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00235"></a>00235              <span class="stringliteral">&quot;OB.Co.OB&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00236"></a>00236              <span class="stringliteral">&quot;OB.Co.OC&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00237"></a>00237              <span class="stringliteral">&quot;OC.Co.OC&quot;</span>:[[1],[1.4661e+02,5.4081e+01]],
<a name="l00238"></a>00238              <span class="stringliteral">&quot;Co.OB.Co&quot;</span>:[[1],[1.4661e+02,1.0312e+03]],
<a name="l00239"></a>00239              <span class="stringliteral">&quot;Co.OC.Co&quot;</span>:[[1],[1.4661e+02,1.0312e+03]]}
<a name="l00240"></a>00240 ThreshAngle = 150
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="comment">### FUNCTION DEFINITIONS ###</span>
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="comment"># In: An atom number and all of the atoms bonded to it.</span>
<a name="l00245"></a>00245 <span class="comment"># Out: All of the angle interactions with this atom at the center.</span>
<a name="l00246"></a>00246 <span class="keyword">def </span>acomb(a,set):
<a name="l00247"></a>00247     c = []
<a name="l00248"></a>00248     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> set:
<a name="l00249"></a>00249         <span class="keywordflow">for</span> j <span class="keywordflow">in</span> set:
<a name="l00250"></a>00250             <span class="keywordflow">if</span> j&gt;i:
<a name="l00251"></a>00251                 c.append([i,a,j])
<a name="l00252"></a>00252     <span class="keywordflow">return</span> c
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment"># In: Atom number A, atom number B, the atoms bonded to atom A, the atoms bonded to atom B.</span>
<a name="l00255"></a>00255 <span class="comment"># Out: All of the dihedral interactions for atom A and atom B.</span>
<a name="l00256"></a>00256 <span class="keyword">def </span>dcomb(a,b,seta,setb):
<a name="l00257"></a>00257     d = []
<a name="l00258"></a>00258     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> seta:
<a name="l00259"></a>00259         <span class="keywordflow">for</span> j <span class="keywordflow">in</span> setb:
<a name="l00260"></a>00260             <span class="keywordflow">if</span> i != b <span class="keywordflow">and</span> j != a:
<a name="l00261"></a>00261                 <span class="keywordflow">if</span> j&gt;i:
<a name="l00262"></a>00262                     d.append([i,a,b,j])
<a name="l00263"></a>00263                 <span class="keywordflow">elif</span> j&lt;i:
<a name="l00264"></a>00264                     d.append([j,b,a,i])
<a name="l00265"></a>00265     <span class="keywordflow">return</span> d
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment"># In: Atom number A, atom number B</span>
<a name="l00268"></a>00268 <span class="comment"># Out: The Cartesian distance between the two atoms in nanometers.</span>
<a name="l00269"></a>00269 <span class="keyword">def </span>dist(a,b):
<a name="l00270"></a>00270     <span class="keywordflow">return</span> dot(R[b]-R[a],R[b]-R[a])**0.5
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment"># In: Three atom numbers</span>
<a name="l00273"></a>00273 <span class="comment"># Out: The angle ABC in degrees.</span>
<a name="l00274"></a>00274 <span class="keyword">def </span>angle(a,b,c):
<a name="l00275"></a>00275     ab = R[a]-R[b];
<a name="l00276"></a>00276     cb = R[c]-R[b];
<a name="l00277"></a>00277     theta=arccos(dot(ab,cb)/(dot(ab,ab)**0.5*dot(cb,cb)**0.5))*180/pi
<a name="l00278"></a>00278     <span class="keywordflow">return</span> theta
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment"># Recursive ring finder</span>
<a name="l00281"></a>00281 <span class="comment"># This is a cool function but we currently don&#39;t use it for anything</span>
<a name="l00282"></a>00282 <span class="keyword">def </span>ring(size,STEP,NOW,PREV):
<a name="l00283"></a>00283     FWD = [i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sbonds[NOW]]
<a name="l00284"></a>00284     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> PREV[1:]:
<a name="l00285"></a>00285         <span class="keywordflow">if</span> i <span class="keywordflow">in</span> FWD:
<a name="l00286"></a>00286             FWD.remove(i)
<a name="l00287"></a>00287     <span class="keywordflow">if</span> STEP &lt;= size:
<a name="l00288"></a>00288         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> FWD:
<a name="l00289"></a>00289             ring(size,STEP+1,i,PREV+[NOW])
<a name="l00290"></a>00290     <span class="keywordflow">if</span> STEP == size+1 <span class="keywordflow">and</span> PREV[-1] == PREV[0]:
<a name="l00291"></a>00291         <span class="keywordflow">if</span> sorted(PREV[:-1]) <span class="keywordflow">not</span> <span class="keywordflow">in</span> ring.rsort:
<a name="l00292"></a>00292             ring.ratoms.append(PREV[:-1])
<a name="l00293"></a>00293             ring.rsort.append(sorted(PREV[:-1]))
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment"># Recursive base type definition</span>
<a name="l00296"></a>00296 <span class="comment"># The initial call is with atomtype(elem,elem)</span>
<a name="l00297"></a>00297 <span class="comment"># Afterward, it goes through the list of base types (CA, CB, CC, CD...)</span>
<a name="l00298"></a>00298 <span class="comment"># until it finds an unused name and returns it</span>
<a name="l00299"></a>00299 <span class="keyword">def </span>atomtype(E, A):
<a name="l00300"></a>00300     <span class="keywordflow">if</span> A <span class="keywordflow">in</span> T:
<a name="l00301"></a>00301         <span class="keywordflow">if</span> A == E:
<a name="l00302"></a>00302             A += <span class="stringliteral">&quot;A&quot;</span>
<a name="l00303"></a>00303             <span class="keywordflow">return</span> atomtype(E, A)
<a name="l00304"></a>00304         <span class="keywordflow">else</span>:
<a name="l00305"></a>00305             ANew = A[:-1] + Alphabet[Alphabet.index(A[-1])+1]
<a name="l00306"></a>00306             <span class="keywordflow">return</span> atomtype(E, ANew)
<a name="l00307"></a>00307     <span class="keywordflow">else</span>:
<a name="l00308"></a>00308         <span class="keywordflow">return</span> A
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment"># Used in neighbor-based base type definition</span>
<a name="l00311"></a>00311 <span class="comment"># Returns a unique &quot;key&quot; corresponding to all of the bonded atoms of atom A.</span>
<a name="l00312"></a>00312 <span class="keyword">def </span>BuildAKey(i):
<a name="l00313"></a>00313     AllNeighbors = [E[j] <span class="keywordflow">for</span> j <span class="keywordflow">in</span> sbonds[i]]
<a name="l00314"></a>00314     AllNeighbors.sort()
<a name="l00315"></a>00315     AKey = E[i] + <span class="stringliteral">&quot;.&quot;</span> + <span class="stringliteral">&quot;.&quot;</span>.join(AllNeighbors)
<a name="l00316"></a>00316     <span class="keywordflow">return</span> AllNeighbors, AKey
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="comment"># This simply prints out the atom number, element, neighbors, and base type of a given atom.</span>
<a name="l00319"></a>00319 <span class="keyword">def </span>PrintInfo(i):
<a name="l00320"></a>00320     AllNeighbors,AKey = BuildAKey(i)
<a name="l00321"></a>00321     <span class="keywordflow">print</span> <span class="stringliteral">&quot;%9i%10s%16s%15s&quot;</span> % (i+1,E[i],<span class="stringliteral">&quot; &quot;</span>.join(AllNeighbors),T[i])
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment"># NOTE: This function is only called by DefineParameters</span>
<a name="l00324"></a>00324 <span class="comment"># Input: Section name (&#39;bondtypes&#39;,&#39;angletypes&#39;,&#39;dihedraltypes&#39;), interaction type (&#39;CA.CB.CT&#39;)</span>
<a name="l00325"></a>00325 <span class="comment"># Output: Filtered OPLS-AA parameters.</span>
<a name="l00326"></a>00326 <span class="comment"># This goes through the ffoplsaabon.itp file and filters out relevant lines for parameter selection.</span>
<a name="l00327"></a>00327 <span class="comment"># A special feature is &quot;recommendations&quot;: If the OPLS nicknames for the input interaction type matches the nicknames on a given line,</span>
<a name="l00328"></a>00328 <span class="comment"># that line is given &quot;points&quot; by the number of matches, denoted by a red carat ^.  </span>
<a name="l00329"></a>00329 <span class="comment"># Note: If we&#39;re working on a dihedral interaction, then the two middle atoms get three points while the edge atoms get one point.</span>
<a name="l00330"></a>00330 <span class="comment"># If all of the nicknames match, then that line gets ten points (otherwise impossible).</span>
<a name="l00331"></a>00331 <span class="comment"># Also: &quot;X&quot; is a wild card for dihedral interactions; it counts as a match but doesn&#39;t qualify for ten points.</span>
<a name="l00332"></a>00332 <span class="keyword">def </span>OPLS_Filter(SectionName,Type):
<a name="l00333"></a>00333     ElementList = [TEDict[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Type.split(<span class="stringliteral">&quot;.&quot;</span>)]
<a name="l00334"></a>00334     NickList = [OPLSNicks[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Type.split(<span class="stringliteral">&quot;.&quot;</span>)]
<a name="l00335"></a>00335     rawfile = os.popen(<span class="stringliteral">&quot;awk &#39;/%s/,(NF==0)&#39; %s&quot;</span> % (SectionName,oplsbon)).readlines()
<a name="l00336"></a>00336     filtered = []
<a name="l00337"></a>00337     original = []
<a name="l00338"></a>00338     already = []
<a name="l00339"></a>00339     elemrev = ElementList[::-1]
<a name="l00340"></a>00340     typerev = NickList[::-1]
<a name="l00341"></a>00341     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> rawfile:
<a name="l00342"></a>00342         sline = line.split()
<a name="l00343"></a>00343         <span class="keywordflow">try</span>:
<a name="l00344"></a>00344             <span class="keywordflow">if</span> len(NickList) == 4:
<a name="l00345"></a>00345                 score = max(sum(array([NickList[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))])*array([1,3,3,1])),sum(array([typerev[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))])*array([1,3,3,1]))) + line.count(<span class="stringliteral">&quot; X &quot;</span>)
<a name="l00346"></a>00346             <span class="keywordflow">else</span>:
<a name="l00347"></a>00347                 score = max(sum(array([NickList[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))])),sum(array([typerev[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))]))) + line.count(<span class="stringliteral">&quot; X &quot;</span>)
<a name="l00348"></a>00348             <span class="keywordflow">if</span> line <span class="keywordflow">in</span> already: <span class="keywordflow">continue</span>
<a name="l00349"></a>00349             already.append(line)
<a name="l00350"></a>00350             <span class="keywordflow">if</span> array([NickList[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))]).all():
<a name="l00351"></a>00351                 filtered.append(line.replace(<span class="stringliteral">&quot;\n&quot;</span>,<span class="stringliteral">&quot;&quot;</span>)+<span class="stringliteral">&quot;\x1b[91m^^^^^^^^^^\x1b[0m\n&quot;</span>)
<a name="l00352"></a>00352                 original.append(line)
<a name="l00353"></a>00353             <span class="keywordflow">elif</span> array([typerev[i] == sline[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(NickList))]).all():
<a name="l00354"></a>00354                 filtered.append(line.replace(<span class="stringliteral">&quot;\n&quot;</span>,<span class="stringliteral">&quot;&quot;</span>)+<span class="stringliteral">&quot;\x1b[91m^^^^^^^^^^\x1b[0m\n&quot;</span>)
<a name="l00355"></a>00355                 original.append(line)
<a name="l00356"></a>00356             <span class="keywordflow">elif</span> array([ElementList[i] <span class="keywordflow">in</span> sline[i][:len(ElementList[i])] <span class="keywordflow">or</span> sline[i] == <span class="stringliteral">&quot;X&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(ElementList))]).all():
<a name="l00357"></a>00357                 <span class="keywordflow">if</span> score &gt; 0:
<a name="l00358"></a>00358                     filtered.append(line.replace(<span class="stringliteral">&quot;\n&quot;</span>,<span class="stringliteral">&quot;&quot;</span>)+<span class="stringliteral">&quot;\x1b[91m%s\x1b[0m\n&quot;</span> % (<span class="stringliteral">&#39;&#39;</span>.join([<span class="stringliteral">&quot;^&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(score)])))
<a name="l00359"></a>00359                     original.append(line)
<a name="l00360"></a>00360                 <span class="keywordflow">else</span>:
<a name="l00361"></a>00361                     filtered.append(line)
<a name="l00362"></a>00362                     original.append(line)
<a name="l00363"></a>00363             <span class="keywordflow">elif</span> array([elemrev[i] <span class="keywordflow">in</span> sline[i][:len(elemrev[i])] <span class="keywordflow">or</span> sline[i] == <span class="stringliteral">&quot;X&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(elemrev))]).all():
<a name="l00364"></a>00364                 <span class="keywordflow">if</span> score &gt; 0:
<a name="l00365"></a>00365                     filtered.append(line.replace(<span class="stringliteral">&quot;\n&quot;</span>,<span class="stringliteral">&quot;&quot;</span>)+<span class="stringliteral">&quot;\x1b[91m%s\x1b[0m\n&quot;</span> % (<span class="stringliteral">&#39;&#39;</span>.join([<span class="stringliteral">&quot;^&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(score)])))
<a name="l00366"></a>00366                     original.append(line)
<a name="l00367"></a>00367                 <span class="keywordflow">else</span>:
<a name="l00368"></a>00368                     filtered.append(line)
<a name="l00369"></a>00369                     original.append(line)
<a name="l00370"></a>00370         <span class="keywordflow">except</span>: <span class="keywordflow">pass</span>
<a name="l00371"></a>00371     <span class="keywordflow">return</span> filtered, original
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment"># Default interaction for when there are no input parameters.</span>
<a name="l00374"></a>00374 <span class="comment"># Usually returns all zeros, but also gives default improper</span>
<a name="l00375"></a>00375 <span class="comment"># dihedrals for aromatic rings.</span>
<a name="l00376"></a>00376 <span class="keyword">def </span>getdefaults(Type,SectionName,Positions):
<a name="l00377"></a>00377     Answer = zeros(len(Positions))
<a name="l00378"></a>00378     Comment = <span class="stringliteral">&#39;Default: all zeros&#39;</span>
<a name="l00379"></a>00379     <span class="keywordflow">if</span> SectionName == <span class="stringliteral">&#39;dihedral&#39;</span>:
<a name="l00380"></a>00380         Answer[0] = 30.33400
<a name="l00381"></a>00381         Answer[2] = -30.33400
<a name="l00382"></a>00382         Comment = <span class="stringliteral">&#39;Default: aromatic ring&#39;</span>
<a name="l00383"></a>00383     <span class="keywordflow">return</span> Answer, Comment
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="comment"># Takes in the text from OPLS_Filter and gives back recommendations.</span>
<a name="l00386"></a>00386 <span class="comment"># This is very simple; it just gives back the line with the highest number of points.</span>
<a name="l00387"></a>00387 <span class="comment"># If the automatic switch is turned on, then it will choose this line automatically.</span>
<a name="l00388"></a>00388 <span class="comment"># If there is no line with ten points, then the answer is ambiguous;</span>
<a name="l00389"></a>00389 <span class="comment"># it will then prompt the user to choose (the user isn&#39;t restricted to choosing</span>
<a name="l00390"></a>00390 <span class="comment"># the most recommended one.)</span>
<a name="l00391"></a>00391 <span class="keyword">def </span>recommend(textlist,manual):
<a name="l00392"></a>00392     goodlines = []
<a name="l00393"></a>00393     currcount = 0
<a name="l00394"></a>00394     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> textlist:
<a name="l00395"></a>00395         starcount = line.count(<span class="stringliteral">&quot;^&quot;</span>)
<a name="l00396"></a>00396         <span class="keywordflow">if</span> starcount &gt; currcount:
<a name="l00397"></a>00397             currcount = starcount
<a name="l00398"></a>00398             goodlines = [textlist.index(line)]
<a name="l00399"></a>00399         <span class="keywordflow">elif</span> starcount == currcount:
<a name="l00400"></a>00400             goodlines.append(textlist.index(line))
<a name="l00401"></a>00401     <span class="keywordflow">if</span> len(goodlines) == 1 <span class="keywordflow">and</span> currcount == 10:
<a name="l00402"></a>00402         <span class="keywordflow">return</span> manual <span class="keywordflow">and</span> 1 <span class="keywordflow">or</span> 0, goodlines
<a name="l00403"></a>00403     <span class="keywordflow">elif</span> len(goodlines) &gt;= 1:
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 1, goodlines
<a name="l00405"></a>00405     <span class="keywordflow">else</span>:
<a name="l00406"></a>00406         <span class="keywordflow">return</span> 1, goodlines
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="comment"># In: A list of atom types separated by periods, as for an interaction type</span>
<a name="l00409"></a>00409 <span class="comment"># Out: The ordered list of atom types</span>
<a name="l00410"></a>00410 <span class="comment"># This function takes care to swap atom types in dihedrals where A and D are the same,</span>
<a name="l00411"></a>00411 <span class="comment"># but B and C are not necessarily the same.</span>
<a name="l00412"></a>00412 <span class="keyword">def </span>Order(string):
<a name="l00413"></a>00413     ssd = string.split(<span class="stringliteral">&quot;.&quot;</span>)
<a name="l00414"></a>00414     <span class="keywordflow">if</span> ssd[0] &gt; ssd[-1]:
<a name="l00415"></a>00415         newlist = ssd[::-1]
<a name="l00416"></a>00416     <span class="keywordflow">else</span>:
<a name="l00417"></a>00417         <span class="keywordflow">if</span> len(ssd) == 4:
<a name="l00418"></a>00418             <span class="keywordflow">if</span> ssd[0] == ssd[3] <span class="keywordflow">and</span> ssd[1] &gt; ssd[2]:
<a name="l00419"></a>00419                 newlist = [ssd[0],ssd[2],ssd[1],ssd[3]]
<a name="l00420"></a>00420             <span class="keywordflow">else</span>:
<a name="l00421"></a>00421                 newlist = ssd
<a name="l00422"></a>00422         <span class="keywordflow">else</span>:
<a name="l00423"></a>00423             newlist = ssd
<a name="l00424"></a>00424     <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>.join(newlist)
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment"># In: SectionName (bondtypes, angletypes, dihedraltypes) and SectionDict (from DefineParameters)</span>
<a name="l00427"></a>00427 <span class="comment"># and prints out a formatted block of parameters, either to the itp file or to screen.</span>
<a name="l00428"></a>00428 <span class="keyword">def </span>PrintTypeSection(SectionName,SectionDict):
<a name="l00429"></a>00429     answer = []
<a name="l00430"></a>00430     answer.append(<span class="stringliteral">&quot;[ %s ]&quot;</span> % SectionName)
<a name="l00431"></a>00431     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(SectionDict):
<a name="l00432"></a>00432         line = <span class="stringliteral">&quot;&quot;</span>
<a name="l00433"></a>00433         <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i.split(<span class="stringliteral">&quot;.&quot;</span>):
<a name="l00434"></a>00434             line += <span class="stringliteral">&quot;%5s&quot;</span> % j
<a name="l00435"></a>00435         line += <span class="stringliteral">&quot;%5i&quot;</span> % SectionDict[i][0]
<a name="l00436"></a>00436         <span class="keywordflow">for</span> j <span class="keywordflow">in</span> SectionDict[i][1]:
<a name="l00437"></a>00437             line += <span class="stringliteral">&quot;% 14.4e&quot;</span> % j
<a name="l00438"></a>00438         <span class="keywordflow">if</span> len(SectionDict[i][2]) &gt; 0:
<a name="l00439"></a>00439             line += <span class="stringliteral">&quot; ; %s&quot;</span> % SectionDict[i][2]
<a name="l00440"></a>00440         answer.append(line)
<a name="l00441"></a>00441     answer.append(<span class="stringliteral">&quot;&quot;</span>)
<a name="l00442"></a>00442     <span class="keywordflow">return</span> answer
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment"># In: SectionName, list of 2 atoms (bonds) or 3 atoms (angles)</span>
<a name="l00445"></a>00445 <span class="comment"># Out: Either the distance between 2 atoms or the angles between 3 atoms</span>
<a name="l00446"></a>00446 <span class="keyword">def </span>GetBaseVals(SectionName,Atoms):
<a name="l00447"></a>00447     <span class="keywordflow">if</span> SectionName == <span class="stringliteral">&quot;bonds&quot;</span>:
<a name="l00448"></a>00448         <span class="keywordflow">return</span> <span class="stringliteral">&quot;%10.5f&quot;</span> % dist(Atoms[0],Atoms[1])
<a name="l00449"></a>00449     <span class="keywordflow">elif</span> SectionName == <span class="stringliteral">&quot;angles&quot;</span>:
<a name="l00450"></a>00450         <span class="keywordflow">return</span> <span class="stringliteral">&quot;%12.5f&quot;</span> % angle(Atoms[0],Atoms[1],Atoms[2])
<a name="l00451"></a>00451     <span class="keywordflow">else</span>:
<a name="l00452"></a>00452         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment"># Prints the 1-4 interactions using the dihedral list.</span>
<a name="l00455"></a>00455 <span class="keyword">def </span>PrintPairs(blist,dlist):
<a name="l00456"></a>00456     answer = [<span class="stringliteral">&quot;[ pairs ]&quot;</span>]
<a name="l00457"></a>00457     printed = []
<a name="l00458"></a>00458     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(dlist):
<a name="l00459"></a>00459         <span class="keywordflow">if</span> sorted([i[0],i[-1]]) <span class="keywordflow">not</span> <span class="keywordflow">in</span> blist <span class="keywordflow">and</span> sorted([i[0],i[-1]]) <span class="keywordflow">not</span> <span class="keywordflow">in</span> printed:
<a name="l00460"></a>00460             printed.append(sorted([i[0],i[-1]]))
<a name="l00461"></a>00461     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(printed):
<a name="l00462"></a>00462         line = <span class="stringliteral">&quot;%5i%5i&quot;</span> % (i[0]+1,i[-1]+1)
<a name="l00463"></a>00463         answer.append(line)
<a name="l00464"></a>00464     answer.append(<span class="stringliteral">&quot;&quot;</span>)
<a name="l00465"></a>00465     <span class="keywordflow">return</span> answer
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment"># In: SectionName (bonds, angles, dihedrals), SectionDict (from DefineParameters),</span>
<a name="l00468"></a>00468 <span class="comment"># SectionList (a list of the specific interactions), PrintBaseVals (a switch),</span>
<a name="l00469"></a>00469 <span class="comment"># Sub180 (substitute parameters for large angles)</span>
<a name="l00470"></a>00470 <span class="comment"># In this section, the specific interaction is printed out, along with the</span>
<a name="l00471"></a>00471 <span class="comment"># base value (bond length, angle) and force constant if desired.</span>
<a name="l00472"></a>00472 <span class="keyword">def </span>PrintItemSection(SectionName,SectionDict,SectionList,PrintBaseVals,Sub180):
<a name="l00473"></a>00473     answer = []
<a name="l00474"></a>00474     answer.append(<span class="stringliteral">&quot;[ %s ]&quot;</span> % SectionName)
<a name="l00475"></a>00475     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(SectionList):
<a name="l00476"></a>00476         line = <span class="stringliteral">&quot;&quot;</span>
<a name="l00477"></a>00477         <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i:
<a name="l00478"></a>00478             line += <span class="stringliteral">&quot;%5i&quot;</span> % (j+1)
<a name="l00479"></a>00479         line += <span class="stringliteral">&quot;%5i&quot;</span> % SectionDict[Order(<span class="stringliteral">&quot;.&quot;</span>.join([BAT[T[j]] <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i]))][0]
<a name="l00480"></a>00480         <span class="keywordflow">if</span> SectionName == <span class="stringliteral">&quot;angles&quot;</span> <span class="keywordflow">and</span> Sub180 <span class="keywordflow">and</span> float(GetBaseVals(SectionName,i)) &gt; ThreshAngle:
<a name="l00481"></a>00481             <span class="keywordflow">try</span>:
<a name="l00482"></a>00482                 line += <span class="stringliteral">&quot;% 14.4e&quot;</span> % altangles[Order(<span class="stringliteral">&quot;.&quot;</span>.join([BAT[T[j]] <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i]))][1][-2]
<a name="l00483"></a>00483                 line += <span class="stringliteral">&quot;% 14.4e&quot;</span> % altangles[Order(<span class="stringliteral">&quot;.&quot;</span>.join([BAT[T[j]] <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i]))][1][-1]
<a name="l00484"></a>00484             <span class="keywordflow">except</span>:
<a name="l00485"></a>00485                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Sub180 has failed for angle %s&quot;</span> % (<span class="stringliteral">&quot;.&quot;</span>.join([<span class="stringliteral">&quot;%i&quot;</span> % j <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i]))
<a name="l00486"></a>00486         <span class="keywordflow">elif</span> PrintBaseVals:
<a name="l00487"></a>00487             line += GetBaseVals(SectionName,i)
<a name="l00488"></a>00488             line += <span class="stringliteral">&quot;% 14.4e&quot;</span> % SectionDict[Order(<span class="stringliteral">&quot;.&quot;</span>.join([BAT[T[j]] <span class="keywordflow">for</span> j <span class="keywordflow">in</span> i]))][1][-1]
<a name="l00489"></a>00489         answer.append(line)
<a name="l00490"></a>00490     answer.append(<span class="stringliteral">&quot;&quot;</span>)
<a name="l00491"></a>00491     <span class="keywordflow">return</span> answer
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment"># This is the big lunker!</span>
<a name="l00494"></a>00494 <span class="comment"># In: InteractionList (a list of the specific interaction), TypeList (list of the bonded interaction types &#39;CA.CB.CT&#39;), </span>
<a name="l00495"></a>00495 <span class="comment"># InteractionName (&#39;bondtypes&#39;,&#39;angletypes&#39;,&#39;dihedraltypes&#39;), InteractionClass (1 for bonds, 1 for angles, 3 for dihedrals),</span>
<a name="l00496"></a>00496 <span class="comment"># Positions (integers corresponding to fields in line where the parameters belong)</span>
<a name="l00497"></a>00497 <span class="comment"># First ask the user whether to go into Automatic Mode</span>
<a name="l00498"></a>00498 <span class="comment"># For each interaction type (e.g. &#39;CA.CB.CT&#39;), do the following:</span>
<a name="l00499"></a>00499 <span class="comment"># Get a selection of candidate lines from ffoplsaabon.itp and recommend parameters</span>
<a name="l00500"></a>00500 <span class="comment"># Pick the parameter automatically if in automatic mode and an unambiguous choice is made</span>
<a name="l00501"></a>00501 <span class="comment"># Ask the user if there are any decisions to be made</span>
<a name="l00502"></a>00502 <span class="comment"># When we are all done, give back a dictionary with InteractionTypes:Parameters</span>
<a name="l00503"></a>00503 <span class="keyword">def </span>DefineParameters(InteractionList,TypeList,InteractionName,SectionName,InteractionClass,Positions):
<a name="l00504"></a>00504     SectionDict = {}
<a name="l00505"></a>00505     choice = raw_input(<span class="stringliteral">&quot;%i &#39;%s&#39; interactions of %i types have been found.  Enter &#39;Yes&#39; to perform automatic parameterization. --&gt; &quot;</span> % (len(InteractionList),InteractionName,len(TypeList)))
<a name="l00506"></a>00506     <span class="keywordflow">if</span> InteractionName == <span class="stringliteral">&#39;bonds&#39;</span> <span class="keywordflow">or</span> InteractionName == <span class="stringliteral">&#39;angles&#39;</span>:
<a name="l00507"></a>00507         ReadBaseVals = raw_input(<span class="stringliteral">&quot;Enter &#39;Yes&#39; to get equilibrium values from source coordinate file (Useful if you did a geometry optimization!) --&gt;&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00508"></a>00508     <span class="keywordflow">if</span> len(choice) &gt; 0:
<a name="l00509"></a>00509         <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00510"></a>00510             Manual,ManualNow = 0,0
<a name="l00511"></a>00511         <span class="keywordflow">else</span>:
<a name="l00512"></a>00512             Manual,ManualNow = 1,1
<a name="l00513"></a>00513     <span class="keywordflow">else</span>:
<a name="l00514"></a>00514         Manual,ManualNow = 0,0
<a name="l00515"></a>00515     <span class="keywordflow">try</span>:
<a name="l00516"></a>00516         <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == ReadBaseVals[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == ReadBaseVals[0] <span class="keywordflow">or</span> ReadBaseVals == <span class="stringliteral">&quot; &quot;</span>:
<a name="l00517"></a>00517             ReadBaseVals = 1
<a name="l00518"></a>00518         <span class="keywordflow">else</span>:
<a name="l00519"></a>00519             ReadBaseVals = 0
<a name="l00520"></a>00520     <span class="keywordflow">except</span>:
<a name="l00521"></a>00521         ReadBaseVals = 0
<a name="l00522"></a>00522     <span class="keywordflow">for</span> Type <span class="keywordflow">in</span> TypeList:
<a name="l00523"></a>00523         Good = []
<a name="l00524"></a>00524         TypeSplit = Type.split(<span class="stringliteral">&quot;.&quot;</span>)
<a name="l00525"></a>00525         Comment = <span class="stringliteral">&#39;OPLS&#39;</span>
<a name="l00526"></a>00526         DefaultComment = <span class="stringliteral">&#39;OPLS&#39;</span>
<a name="l00527"></a>00527         <span class="keywordflow">if</span> ReadBaseVals:
<a name="l00528"></a>00528             BaseVals = []
<a name="l00529"></a>00529             <span class="keywordflow">for</span> item <span class="keywordflow">in</span> InteractionList:
<a name="l00530"></a>00530                 <span class="comment"># This complicated line gets a list of base bond-lengths or angles from the atoms that match</span>
<a name="l00531"></a>00531                 <span class="comment"># Note that the data structures are apparent here: OPLSNicks[Bonded_Type[Base_Type[Atom_Number]]]</span>
<a name="l00532"></a>00532                 <span class="keywordflow">if</span> [OPLSNicks[BAT[T[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> item] == [OPLSNicks[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> TypeSplit] <span class="keywordflow">or</span> [OPLSNicks[BAT[T[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> item] == [OPLSNicks[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> TypeSplit[::-1]]:
<a name="l00533"></a>00533                     BaseVals.append(float(GetBaseVals(InteractionName,item)))
<a name="l00534"></a>00534             BaseVals = array(BaseVals)
<a name="l00535"></a>00535         OPLSChoices, RawLines = OPLS_Filter(SectionName,Type)
<a name="l00536"></a>00536         ManualNow, Good = recommend(OPLSChoices,Manual)
<a name="l00537"></a>00537         <span class="keywordflow">if</span> <span class="keywordflow">not</span> Manual:
<a name="l00538"></a>00538             <span class="keywordflow">if</span> ManualNow:
<a name="l00539"></a>00539                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Automatic parameterization failed (but don&#39;t worry), going to Manual Selection&quot;</span>
<a name="l00540"></a>00540         <span class="keywordflow">if</span> <span class="keywordflow">not</span> ManualNow:
<a name="l00541"></a>00541             Selection = Good[0]
<a name="l00542"></a>00542             Parameters = [float(OPLSChoices[Selection].split()[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Positions]
<a name="l00543"></a>00543             <span class="keywordflow">if</span> len(RawLines[Selection].split(<span class="stringliteral">&#39;;&#39;</span>)) &gt; 1:
<a name="l00544"></a>00544                 DefaultComment = <span class="stringliteral">&quot;OPLS &quot;</span> + RawLines[Selection].split(<span class="stringliteral">&#39;;&#39;</span>)[1].strip()
<a name="l00545"></a>00545             <span class="keywordflow">if</span> ReadBaseVals:
<a name="l00546"></a>00546                 Parameters[0] = mean(BaseVals)
<a name="l00547"></a>00547                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Automatic parameterization of %s %s using base geometry, std deviation is %.6f&quot;</span> % (Type,InteractionName,std(BaseVals))
<a name="l00548"></a>00548                 DefaultComment += <span class="stringliteral">&#39;, geom from xyz&#39;</span>
<a name="l00549"></a>00549             <span class="keywordflow">print</span> <span class="stringliteral">&quot;We got these parameters:&quot;</span>,
<a name="l00550"></a>00550             <span class="keywordflow">print</span> <span class="stringliteral">&quot;&quot;</span>.join([<span class="stringliteral">&quot;%-6s&quot;</span> % i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Type.split(<span class="stringliteral">&quot;.&quot;</span>)]), <span class="stringliteral">&quot;%5i&quot;</span> % InteractionClass, <span class="stringliteral">&quot;&quot;</span>.join([<span class="stringliteral">&quot;% 10.5f&quot;</span> % i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Parameters])
<a name="l00551"></a>00551             <span class="keywordflow">print</span>
<a name="l00552"></a>00552         <span class="keywordflow">else</span>:
<a name="l00553"></a>00553             DefaultParams, DefaultComment = getdefaults(Type,InteractionName,Positions) <span class="comment"># getdefaults code returns zeros most of the time.</span>
<a name="l00554"></a>00554             <span class="keywordflow">try</span>:
<a name="l00555"></a>00555                 <span class="keywordflow">try</span>:
<a name="l00556"></a>00556                     DefaultParams = [float(OPLSChoices[Good[0]].split()[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Positions]
<a name="l00557"></a>00557                     <span class="keywordflow">if</span> len(RawLines[Good[0]].split(<span class="stringliteral">&#39;;&#39;</span>)) &gt; 1:
<a name="l00558"></a>00558                         DefaultComment = <span class="stringliteral">&quot;OPLS &quot;</span> + RawLines[Good[0]].split(<span class="stringliteral">&#39;;&#39;</span>)[1].strip()
<a name="l00559"></a>00559                 <span class="keywordflow">except</span>:
<a name="l00560"></a>00560                     DefaultParams = [float(OPLSChoices[0].split()[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Positions]
<a name="l00561"></a>00561                     <span class="keywordflow">if</span> len(RawLines[0].split(<span class="stringliteral">&#39;;&#39;</span>)) &gt; 1:
<a name="l00562"></a>00562                         DefaultComment = <span class="stringliteral">&quot;OPLS &quot;</span> + RawLines[0].split(<span class="stringliteral">&#39;;&#39;</span>)[1].strip()
<a name="l00563"></a>00563             <span class="keywordflow">except</span>:
<a name="l00564"></a>00564                 <span class="keywordflow">pass</span>
<a name="l00565"></a>00565             <span class="keywordflow">if</span> ReadBaseVals:
<a name="l00566"></a>00566                 DefaultParams[0] = mean(BaseVals)
<a name="l00567"></a>00567                 DefaultComment += <span class="stringliteral">&#39;, geom from xyz&#39;</span>
<a name="l00568"></a>00568             <span class="keywordflow">for</span> line <span class="keywordflow">in</span> OPLSChoices:
<a name="l00569"></a>00569                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;%5i&quot;</span> % OPLSChoices.index(line),line,
<a name="l00570"></a>00570             <span class="keywordflow">if</span> len(Good) == 0:
<a name="l00571"></a>00571                 <span class="keywordflow">print</span> <span class="stringliteral">&quot; No recommended choices! &quot;</span>
<a name="l00572"></a>00572             <span class="keywordflow">else</span>:
<a name="l00573"></a>00573                 <span class="keywordflow">print</span> <span class="stringliteral">&quot; --- RECOMMENDED CHOICES --- &quot;</span>
<a name="l00574"></a>00574                 <span class="keywordflow">for</span> item <span class="keywordflow">in</span> Good:
<a name="l00575"></a>00575                     <span class="keywordflow">print</span> item, OPLSChoices[item],
<a name="l00576"></a>00576             <span class="keywordflow">print</span> <span class="stringliteral">&quot; --- DEFAULT PARAMETERS  ---&quot;</span>
<a name="l00577"></a>00577             <span class="keywordflow">print</span> <span class="stringliteral">&quot;&quot;</span>.join([<span class="stringliteral">&quot;%-6s&quot;</span> % i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Type.split(<span class="stringliteral">&quot;.&quot;</span>)]), <span class="stringliteral">&quot;%5i&quot;</span> % InteractionClass, <span class="stringliteral">&quot;&quot;</span>.join([<span class="stringliteral">&quot;% 10.5f&quot;</span> % i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> DefaultParams])
<a name="l00578"></a>00578             <span class="keywordflow">if</span> ReadBaseVals:
<a name="l00579"></a>00579                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Standard deviation of all equilibrium %s of this type is %.6f&quot;</span> % (InteractionName,std(BaseVals))
<a name="l00580"></a>00580             line = raw_input(<span class="stringliteral">&quot;\nFor a &#39;%s&#39; interaction involving %s (OPLS types %s), \nselect line number from above, type your own parameters, \nor hit Enter to accept default. (# of \x1b[91m^\x1b[0m symbols indicate score) --&gt; &quot;</span> % (InteractionName,<span class="stringliteral">&quot;-&quot;</span>.join(Type.split(<span class="stringliteral">&quot;.&quot;</span>)),<span class="stringliteral">&quot;-&quot;</span>.join([OPLSNicks[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Type.split(<span class="stringliteral">&quot;.&quot;</span>)])))
<a name="l00581"></a>00581             <span class="keywordflow">try</span>:
<a name="l00582"></a>00582                 Selection = int(line.strip())
<a name="l00583"></a>00583                 Parameters = [float(OPLSChoices[Selection].split()[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> Positions]
<a name="l00584"></a>00584                 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Going with the following parameter selection: &quot;</span>
<a name="l00585"></a>00585                 <span class="keywordflow">print</span> Selection, OPLSChoices[Selection]
<a name="l00586"></a>00586                 <span class="keywordflow">if</span> len(RawLines[Selection].split(<span class="stringliteral">&#39;;&#39;</span>)) &gt; 1:
<a name="l00587"></a>00587                     Comment = <span class="stringliteral">&quot;OPLS &quot;</span> + RawLines[Selection].split(<span class="stringliteral">&#39;;&#39;</span>)[1].strip()
<a name="l00588"></a>00588             <span class="keywordflow">except</span>:
<a name="l00589"></a>00589                 <span class="keywordflow">try</span>:
<a name="l00590"></a>00590                     <span class="keywordflow">if</span> len(line.split()) == len(Positions):
<a name="l00591"></a>00591                         <span class="keywordflow">print</span> <span class="stringliteral">&quot;Going with user-specified parameters.&quot;</span>
<a name="l00592"></a>00592                         Parameters = [float(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> line.split()]
<a name="l00593"></a>00593                         Comment = <span class="stringliteral">&#39;User Specified Parameter&#39;</span>
<a name="l00594"></a>00594                     <span class="keywordflow">else</span>:
<a name="l00595"></a>00595                         <span class="keywordflow">print</span> <span class="stringliteral">&quot;No selection or user-specified parameters given, going with the default parameters.&quot;</span>
<a name="l00596"></a>00596                         Parameters = DefaultParams
<a name="l00597"></a>00597                         Comment = DefaultComment
<a name="l00598"></a>00598                 <span class="keywordflow">except</span>:
<a name="l00599"></a>00599                     <span class="keywordflow">print</span> <span class="stringliteral">&quot;No selection or user-specified parameters given, going with the default parameters.&quot;</span>
<a name="l00600"></a>00600                     Parameters = DefaultParams
<a name="l00601"></a>00601                     Comment = DefaultComment
<a name="l00602"></a>00602             <span class="keywordflow">print</span>
<a name="l00603"></a>00603         SectionDict[Type] = [InteractionClass,Parameters,Comment]
<a name="l00604"></a>00604     <span class="keywordflow">print</span> <span class="stringliteral">&quot;--- Finished Selecting %s Parameters ---&quot;</span> % InteractionName
<a name="l00605"></a>00605     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintTypeSection(SectionName,SectionDict):
<a name="l00606"></a>00606         <span class="keywordflow">print</span> line
<a name="l00607"></a>00607     <span class="keywordflow">return</span> SectionDict
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="comment">### END FUNCTION DEFINITIONS ###</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="comment">### BUILDING CONNECTIVITY MATRIX ###</span>
<a name="l00612"></a>00612         
<a name="l00613"></a>00613 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00614"></a>00614     sbvec = [k <span class="keywordflow">for</span> k <span class="keywordflow">in</span> abonds[i]]
<a name="l00615"></a>00615     <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(na):
<a name="l00616"></a>00616         <span class="keywordflow">if</span> i <span class="keywordflow">in</span> abonds[j]:
<a name="l00617"></a>00617             sbvec.append(j)
<a name="l00618"></a>00618     sbonds.append([k <span class="keywordflow">for</span> k <span class="keywordflow">in</span> sort(sbvec)])
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="comment">### DEFINING ATOM TYPES ###</span>
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="keywordflow">if</span> len(preatom) == len(sbonds):
<a name="l00623"></a>00623     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Using pre-defined atom types in Gaussian .com file (syntax Element X Y Z ! AtomType)&quot;</span>
<a name="l00624"></a>00624     AtomTypeSwitch = 1
<a name="l00625"></a>00625 <span class="keywordflow">else</span>:
<a name="l00626"></a>00626     AtomTypeSwitch = raw_input(<span class="stringliteral">&quot;Enter &#39;1&#39; for neighbor-based atom type generation or &#39;0&#39; for simple element-based atom types. --&gt;&quot;</span>)[0] == <span class="stringliteral">&#39;1&#39;</span>
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="keywordflow">print</span> <span class="stringliteral">&quot;\n--- Number --- Element --- Neighbors --- Assigned Type ---\n&quot;</span>
<a name="l00629"></a>00629 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(sbonds)): <span class="comment"># [ELEMENT NEIGHBOR1 NEIGHBOR2...]</span>
<a name="l00630"></a>00630     AllNeighbors,AKey = BuildAKey(i)
<a name="l00631"></a>00631     <span class="keywordflow">if</span> len(preatom) == len(sbonds):
<a name="l00632"></a>00632         AtomType = preatom[i]
<a name="l00633"></a>00633     <span class="keywordflow">else</span>:
<a name="l00634"></a>00634         <span class="keywordflow">try</span>:
<a name="l00635"></a>00635             AtomType = TDict[AKey]
<a name="l00636"></a>00636         <span class="keywordflow">except</span>:
<a name="l00637"></a>00637             AtomType = atomtype(E[i],E[i])
<a name="l00638"></a>00638             TDict[AKey] = AtomType
<a name="l00639"></a>00639     <span class="comment"># LPW added a switch to make all carbon-bonded hydrogen &quot;HC&quot; and all oxygen-bonded hydrogen &quot;HO&quot;</span>
<a name="l00640"></a>00640     <span class="keywordflow">if</span> AtomTypeSwitch:
<a name="l00641"></a>00641         T.append(AtomType)
<a name="l00642"></a>00642     <span class="keywordflow">else</span>:
<a name="l00643"></a>00643         T.append(E[i])
<a name="l00644"></a>00644     PrintInfo(i)
<a name="l00645"></a>00645     TEDict[AtomType] = E[i]
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 choice = raw_input(<span class="stringliteral">&quot;Modify the list? (Enter for no) --&gt; &quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00648"></a>00648 <span class="keywordflow">print</span>
<a name="l00649"></a>00649 <span class="keywordflow">while</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00650"></a>00650     <span class="keywordflow">print</span> <span class="stringliteral">&quot;\n--- Number --- Element --- Neighbors --- Assigned Type ---\n&quot;</span>
<a name="l00651"></a>00651     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(T)):
<a name="l00652"></a>00652         PrintInfo(i)
<a name="l00653"></a>00653     line = raw_input(<span class="stringliteral">&quot;Enter the index of the atom you wish to change, or enter Q to quit. --&gt;&quot;</span>)
<a name="l00654"></a>00654     <span class="keywordflow">print</span>
<a name="l00655"></a>00655     <span class="keywordflow">if</span> line == <span class="stringliteral">&quot;Q&quot;</span> <span class="keywordflow">or</span> line == <span class="stringliteral">&#39;q&#39;</span>:
<a name="l00656"></a>00656         <span class="keywordflow">break</span>
<a name="l00657"></a>00657     Index = int(line.strip())
<a name="l00658"></a>00658     line = raw_input(<span class="stringliteral">&quot;Enter the new type of atom %i. --&gt; &quot;</span> % Index)
<a name="l00659"></a>00659     <span class="keywordflow">print</span>
<a name="l00660"></a>00660     Type = line.strip()
<a name="l00661"></a>00661     <span class="keywordflow">try</span>:
<a name="l00662"></a>00662         T[Index-1] = Type
<a name="l00663"></a>00663         TEDict[Type] = E[Index-1]
<a name="l00664"></a>00664     <span class="keywordflow">except</span>:
<a name="l00665"></a>00665         choice = raw_input(<span class="stringliteral">&quot;There was an error.  Do you want to continue? --&gt; &quot;</span>)
<a name="l00666"></a>00666         <span class="keywordflow">print</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 raw_input(<span class="stringliteral">&quot;\nAtom Types Saved. Press Enter&quot;</span>)
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="comment">### SEARCHING FOR RINGS ###</span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 ring.ratoms = []
<a name="l00673"></a>00673 ring.rsort = []
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="keywordflow">print</span> <span class="stringliteral">&quot;\nFinding Rings...&quot;</span>,
<a name="l00676"></a>00676 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00677"></a>00677     ring(6,0,i,[])
<a name="l00678"></a>00678     ring(5,0,i,[])
<a name="l00679"></a>00679 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> ring.ratoms:
<a name="l00680"></a>00680     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Ring found at&quot;</span>,i
<a name="l00681"></a>00681 <span class="keywordflow">print</span> <span class="stringliteral">&quot;...Done&quot;</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683 <span class="comment">### SELECTING NONBONDED PARAMETERS ###</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="comment"># This section should probably be its own function, but it&#39;s only called once.</span>
<a name="l00686"></a>00686 <span class="comment"># This loop goes through the base atom types and selects the bonded types and OPLS nicknames.</span>
<a name="l00687"></a>00687 <span class="comment"># If the types are not chosen automatically, then the user gets to pick from a list.</span>
<a name="l00688"></a>00688 <span class="keywordflow">print</span> <span class="stringliteral">&quot;%i atoms of %i distinct types have been found.  Press Enter.&quot;</span> % (len(T),len(set(T)))
<a name="l00689"></a>00689 raw_input()
<a name="l00690"></a>00690 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(list(set(T))):
<a name="l00691"></a>00691     Element = TEDict[i]
<a name="l00692"></a>00692     OPLSChoices = list(os.popen(<span class="stringliteral">&quot;awk &#39;$2 ~ /%s/&#39; %s | awk &#39;(($4 - %.3f) &lt; 0.1 &amp;&amp; ($4 - %.3f) &gt; -0.1)&#39;&quot;</span> % (Element,oplsnb,PeriodicTable[Element],PeriodicTable[Element])).readlines())
<a name="l00693"></a>00693     ChoicesByName = {}
<a name="l00694"></a>00694     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> OPLSChoices:
<a name="l00695"></a>00695         ChoicesByName[line.split()[0]] = line
<a name="l00696"></a>00696     <span class="keywordflow">try</span>:
<a name="l00697"></a>00697         <span class="comment"># The contents of this if statement are invoked only if a valid OPLS type is indicated in the Gaussian .com file</span>
<a name="l00698"></a>00698         <span class="comment"># using either ! ATYPE custom_type opls_xxx or Element x y z ! opls_xxx</span>
<a name="l00699"></a>00699         <span class="keywordflow">if</span> predict[i] <span class="keywordflow">in</span> ChoicesByName:
<a name="l00700"></a>00700             <span class="keywordflow">print</span> <span class="stringliteral">&quot;ATYPE definition found for %s!&quot;</span> % i
<a name="l00701"></a>00701             Selection = predict[i]
<a name="l00702"></a>00702             SelectedLine = ChoicesByName[Selection]
<a name="l00703"></a>00703             sline = SelectedLine.split()
<a name="l00704"></a>00704             <span class="keywordflow">print</span> <span class="stringliteral">&quot;%s -&gt; %10s%5s%5i%10.5f%10.3f%15.5e%15.5e  &quot;</span> % (i, sline[0],sline[1],int(sline[2]),float(sline[3]),float(sline[4]),float(sline[6]),float(sline[7])), OPLSExplanations[sline[0]]
<a name="l00705"></a>00705             <span class="keywordflow">print</span>
<a name="l00706"></a>00706             ANum,Q,SIG,EPS = int(SelectedLine.split()[2]),float(SelectedLine.split()[4]),float(SelectedLine.split()[6]),float(SelectedLine.split()[7])
<a name="l00707"></a>00707             COM = <span class="stringliteral">&quot;OPLS &quot;</span> + OPLSExplanations[sline[0]]
<a name="l00708"></a>00708             <span class="comment"># &quot;Orthodox&quot; OPLS; base types are opls_xxx.  In this case, go to new bonded atom types.</span>
<a name="l00709"></a>00709             <span class="keywordflow">if</span> <span class="stringliteral">&quot;opls&quot;</span> <span class="keywordflow">in</span> i:
<a name="l00710"></a>00710                 BAT[i] = SelectedLine.split()[1]<span class="comment">#OPLSNicks[i]</span>
<a name="l00711"></a>00711                 OPLSNicks[BAT[i]] = BAT[i]
<a name="l00712"></a>00712             <span class="comment"># Base types and bonded types are custom names; don&#39;t have to use opls_xxx, but still assign OPLS nicknames</span>
<a name="l00713"></a>00713             <span class="keywordflow">else</span>:
<a name="l00714"></a>00714                 BAT[i] = i
<a name="l00715"></a>00715                 OPLSNicks[BAT[i]] = SelectedLine.split()[1]
<a name="l00716"></a>00716             TEDict[BAT[i]] = Element
<a name="l00717"></a>00717             M[i] = [ANum,PeriodicTable[Element],SIG,EPS,COM]
<a name="l00718"></a>00718             QDict[i] = float(<span class="stringliteral">&quot;%.4f&quot;</span> % Q)
<a name="l00719"></a>00719             <span class="keywordflow">continue</span>
<a name="l00720"></a>00720     <span class="keywordflow">except</span>: <span class="keywordflow">pass</span>
<a name="l00721"></a>00721     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> OPLSChoices:
<a name="l00722"></a>00722         sline = line.split()
<a name="l00723"></a>00723         <span class="keywordflow">print</span> <span class="stringliteral">&quot;-&gt; %5i &lt;- %10s%5s%5i%10.5f%10.3f%15.5e%15.5e  &quot;</span> % (OPLSChoices.index(line),sline[0],sline[1],int(sline[2]),float(sline[3]),float(sline[4]),float(sline[6]),float(sline[7])), OPLSExplanations[line.split()[0]]
<a name="l00724"></a>00724     line = raw_input(<span class="stringliteral">&quot;For Atomtype %s, please select the corresponding OPLS atomtype from above by NUMBER (sequential) or NAME (opls_xxx), or enter three parameters of your own: Q SIG EPS --&gt; &quot;</span> % i)
<a name="l00725"></a>00725     <span class="keywordflow">print</span>
<a name="l00726"></a>00726     <span class="keywordflow">if</span> len(line.split()) == 3:
<a name="l00727"></a>00727         <span class="keywordflow">try</span>:
<a name="l00728"></a>00728             <span class="comment"># If the user enters custom parameters, then there is no corresponding OPLS atomtype.</span>
<a name="l00729"></a>00729             <span class="comment"># In this case, there is no OPLS nickname either, and we will attempt to get one by simply setting it equal to the base type.</span>
<a name="l00730"></a>00730             Q,SIG,EPS = [float(j) <span class="keywordflow">for</span> j <span class="keywordflow">in</span> line.split()]
<a name="l00731"></a>00731             COM = <span class="stringliteral">&#39;User Specified Atomtype&#39;</span>
<a name="l00732"></a>00732             BAT[i] = i
<a name="l00733"></a>00733             OPLSNicks[BAT[i]] = i
<a name="l00734"></a>00734             TEDict[BAT[i]] = Element
<a name="l00735"></a>00735         <span class="keywordflow">except</span>:
<a name="l00736"></a>00736             <span class="keywordflow">print</span> <span class="stringliteral">&quot;An error has occurred in getting nonbonded parameters.&quot;</span>
<a name="l00737"></a>00737     <span class="keywordflow">else</span>:
<a name="l00738"></a>00738         <span class="keywordflow">try</span>:
<a name="l00739"></a>00739             <span class="keywordflow">try</span>:
<a name="l00740"></a>00740                 Selection = int(line.strip())
<a name="l00741"></a>00741                 SelectedLine = OPLSChoices[Selection]
<a name="l00742"></a>00742             <span class="keywordflow">except</span>:
<a name="l00743"></a>00743                 Selection = line.strip()
<a name="l00744"></a>00744                 SelectedLine = ChoicesByName[Selection]
<a name="l00745"></a>00745         <span class="keywordflow">except</span>:
<a name="l00746"></a>00746             <span class="keywordflow">print</span> <span class="stringliteral">&quot;An error has occurred in getting nonbonded parameters.&quot;</span>
<a name="l00747"></a>00747         <span class="keywordflow">print</span> Selection,SelectedLine
<a name="l00748"></a>00748         ANum,Q,SIG,EPS = int(SelectedLine.split()[2]),float(SelectedLine.split()[4]),float(SelectedLine.split()[6]),float(SelectedLine.split()[7])
<a name="l00749"></a>00749         COM = <span class="stringliteral">&quot;OPLS &quot;</span> + OPLSExplanations[sline[0]]
<a name="l00750"></a>00750         BAT[i] = i
<a name="l00751"></a>00751         OPLSNicks[BAT[i]] = SelectedLine.split()[1]
<a name="l00752"></a>00752         TEDict[BAT[i]] = Element
<a name="l00753"></a>00753     M[i] = [ANum,PeriodicTable[Element],SIG,EPS,COM]
<a name="l00754"></a>00754     QDict[i] = float(<span class="stringliteral">&quot;%.4f&quot;</span> % Q)
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="comment"># Try to zero out the atomic charge.</span>
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="keywordflow">print</span> <span class="stringliteral">&quot;The following code aims to get an integer-charge molecule using precision 4 floating points.&quot;</span>
<a name="l00759"></a>00759 TQ = sum([QDict[T[i]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na)])
<a name="l00760"></a>00760 <span class="keywordflow">print</span> <span class="stringliteral">&quot;All atom types have been selected; molecule has a net charge of %.4f&quot;</span> % TQ
<a name="l00761"></a>00761 Corr1 = (float(<span class="stringliteral">&quot;%.4f&quot;</span> % (-1*TQ/na)))
<a name="l00762"></a>00762 choice = raw_input(<span class="stringliteral">&quot;Create overall integer charge (enter integer), enter your own (enter float), or skip this step (hit Enter)? --&gt; &quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00763"></a>00763 <span class="comment">#if &#39;y&#39; == choice[0] or &#39;Y&#39; == choice[0]:</span>
<a name="l00764"></a>00764 <span class="keywordflow">if</span> isint(choice.strip()):
<a name="l00765"></a>00765     WantQ = int(choice)
<a name="l00766"></a>00766     Corr1 = (float(<span class="stringliteral">&quot;%.4f&quot;</span> % ((WantQ - 1*TQ)/na)))
<a name="l00767"></a>00767     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> QDict:
<a name="l00768"></a>00768         QDict[i] += Corr1
<a name="l00769"></a>00769     TQ = sum([QDict[T[i]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na)])
<a name="l00770"></a>00770     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Adding a charge of %.4f to each atom&quot;</span> % Corr1
<a name="l00771"></a>00771     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Now all atom types have been selected; molecule has a net charge of %.4f&quot;</span> % TQ
<a name="l00772"></a>00772 <span class="keywordflow">else</span>:
<a name="l00773"></a>00773     <span class="keywordflow">try</span>:
<a name="l00774"></a>00774         Corr1 = float(choice)
<a name="l00775"></a>00775         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> QDict:
<a name="l00776"></a>00776             QDict[i] += Corr1
<a name="l00777"></a>00777         TQ = sum([QDict[T[i]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na)])
<a name="l00778"></a>00778         <span class="keywordflow">print</span> <span class="stringliteral">&quot;Now all atom types have been selected; molecule has a net charge of %.4f&quot;</span> % TQ
<a name="l00779"></a>00779     <span class="keywordflow">except</span>: <span class="keywordflow">print</span> <span class="stringliteral">&quot;You didn&#39;t enter a number, exiting this section&quot;</span>
<a name="l00780"></a>00780                 
<a name="l00781"></a>00781 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> QDict:
<a name="l00782"></a>00782     AtomTypeCount[i] = sum(i == array(T))
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 PrintSwitch = 0
<a name="l00785"></a>00785 <span class="keywordflow">while</span> abs(TQ - int(TQ)) &gt; 1e-5:
<a name="l00786"></a>00786     <span class="keywordflow">print</span>
<a name="l00787"></a>00787     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Atom Counts:&quot;</span>, AtomTypeCount
<a name="l00788"></a>00788     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Total charge: % .4f&quot;</span> %  TQ
<a name="l00789"></a>00789     choice = raw_input(<span class="stringliteral">&quot;Manually add charge to an atom type using: Atype dQ (Q or Enter quits) ? --&gt; &quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00790"></a>00790     <span class="keywordflow">if</span> <span class="stringliteral">&#39;q&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Q&#39;</span> == choice[0] <span class="keywordflow">or</span> choice == <span class="stringliteral">&quot; &quot;</span>: <span class="keywordflow">break</span>
<a name="l00791"></a>00791     <span class="keywordflow">else</span>:
<a name="l00792"></a>00792         <span class="keywordflow">try</span>:
<a name="l00793"></a>00793             QDict[choice.split()[0]] += float(choice.split()[1])
<a name="l00794"></a>00794         <span class="keywordflow">except</span>: <span class="keywordflow">print</span> <span class="stringliteral">&quot;The input cannot be parsed&quot;</span>
<a name="l00795"></a>00795     TQ = sum([QDict[T[i]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na)])
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="keywordflow">print</span>
<a name="l00798"></a>00798 <span class="keywordflow">print</span> <span class="stringliteral">&quot;Charges are GOOD, molecule has a net charge of %.4f&quot;</span> % TQ
<a name="l00799"></a>00799 <span class="keywordflow">print</span>
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="keywordflow">print</span> <span class="stringliteral">&quot;--- FINISHED SELECTING NONBONDED PARAMETERS ---&quot;</span>
<a name="l00802"></a>00802 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> M:
<a name="l00803"></a>00803     <span class="keywordflow">print</span> i, <span class="stringliteral">&quot;: ANum = %5i M = %.4f Q = % .3f SIG = %.4f EPS = %.4f&quot;</span> % (M[i][0],M[i][1],QDict[i],M[i][2],M[i][3])
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="comment">### DETECTION AND PARAMETERIZATION OF BONDS ###</span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00808"></a>00808     <span class="keywordflow">for</span> j <span class="keywordflow">in</span> abonds[i]:
<a name="l00809"></a>00809         BList.append(sorted([i,j]))
<a name="l00810"></a>00810         BType = <span class="stringliteral">&quot;.&quot;</span>.join(sorted([BAT[T[i]],BAT[T[j]]]))
<a name="l00811"></a>00811         <span class="keywordflow">if</span> BType <span class="keywordflow">not</span> <span class="keywordflow">in</span> BTypeList:
<a name="l00812"></a>00812             BTypeList.append(BType)
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 BTypeList.sort()
<a name="l00815"></a>00815 BondTypes = DefineParameters(BList,BTypeList,<span class="stringliteral">&#39;bonds&#39;</span>,<span class="stringliteral">&#39;bondtypes&#39;</span>,1,[3,4])
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="comment">### DETECTION AND PARAMETERIZATION OF ANGLES ###</span>
<a name="l00818"></a>00818     
<a name="l00819"></a>00819 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00820"></a>00820     alist = acomb(i,sbonds[i])
<a name="l00821"></a>00821     <span class="keywordflow">for</span> j <span class="keywordflow">in</span> alist:
<a name="l00822"></a>00822         AList.append(j)
<a name="l00823"></a>00823         acs = sorted([BAT[T[j[0]]],BAT[T[j[2]]]])
<a name="l00824"></a>00824         AType = <span class="stringliteral">&#39;.&#39;</span>.join([acs[0],BAT[T[j[1]]],acs[1]])
<a name="l00825"></a>00825         <span class="keywordflow">if</span> AType <span class="keywordflow">not</span> <span class="keywordflow">in</span> ATypeList:
<a name="l00826"></a>00826             ATypeList.append(AType)
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 ATypeList.sort()
<a name="l00829"></a>00829 AngleTypes = DefineParameters(AList,ATypeList,<span class="stringliteral">&#39;angles&#39;</span>,<span class="stringliteral">&#39;angletypes&#39;</span>,1,[4,5])
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="comment">### DETECTION AND PARAMETERIZATION OF DIHEDRALS ###</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(BList)):
<a name="l00834"></a>00834     dlist = dcomb(BList[i][0],BList[i][1],sbonds[BList[i][0]],sbonds[BList[i][1]])
<a name="l00835"></a>00835     <span class="keywordflow">for</span> j <span class="keywordflow">in</span> dlist:
<a name="l00836"></a>00836         DList.append(j)
<a name="l00837"></a>00837         <span class="keywordflow">if</span> BAT[T[j[0]]] &lt; BAT[T[j[3]]]:
<a name="l00838"></a>00838             DType = <span class="stringliteral">&#39;.&#39;</span>.join([BAT[T[j[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(4)])
<a name="l00839"></a>00839         <span class="keywordflow">elif</span> BAT[T[j[0]]] &gt; BAT[T[j[3]]]:
<a name="l00840"></a>00840             DType = <span class="stringliteral">&#39;.&#39;</span>.join([BAT[T[j[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(3,-1,-1)])
<a name="l00841"></a>00841         <span class="keywordflow">else</span>:
<a name="l00842"></a>00842             <span class="keywordflow">if</span> BAT[T[j[1]]] &lt;= BAT[T[j[2]]]:
<a name="l00843"></a>00843                 DType = <span class="stringliteral">&#39;.&#39;</span>.join([BAT[T[j[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(4)])
<a name="l00844"></a>00844             <span class="keywordflow">else</span>:
<a name="l00845"></a>00845                 DType = <span class="stringliteral">&#39;.&#39;</span>.join([BAT[T[j[i]]] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(3,-1,-1)])
<a name="l00846"></a>00846         <span class="keywordflow">if</span> DType <span class="keywordflow">not</span> <span class="keywordflow">in</span> DTypeList:
<a name="l00847"></a>00847             DTypeList.append(DType)
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 DTypeList.sort()
<a name="l00850"></a>00850 DihedralTypes = DefineParameters(DList,DTypeList,<span class="stringliteral">&#39;dihedral&#39;</span>,<span class="stringliteral">&#39;dihedraltypes&#39;</span>,3,[5,6,7,8,9,10])
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="keyword">def </span>printitp():
<a name="l00854"></a>00854     itpfile = open(argv[1].replace(<span class="stringliteral">&#39;.com&#39;</span>,<span class="stringliteral">&#39;.itp&#39;</span>),<span class="stringliteral">&#39;w&#39;</span>)
<a name="l00855"></a>00855     <span class="comment"># Prints some header stuff.</span>
<a name="l00856"></a>00856     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;[ defaults ]&#39;</span>
<a name="l00857"></a>00857     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-5i%-5i%-10s%5.1f%5.1f&#39;</span> % (1,2,<span class="stringliteral">&#39;yes&#39;</span>,0.5,0.5) <span class="comment"># Defaults</span>
<a name="l00858"></a>00858     <span class="comment"># Prints atom types and VdW parameters.</span>
<a name="l00859"></a>00859     <span class="keywordflow">print</span> &gt;&gt; itpfile
<a name="l00860"></a>00860     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;[ atomtypes ]&#39;</span>
<a name="l00861"></a>00861     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted([j <span class="keywordflow">for</span> j <span class="keywordflow">in</span> M]):
<a name="l00862"></a>00862         <span class="keywordflow">if</span> i == BAT[i]:
<a name="l00863"></a>00863             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5i%10.4f%10.4f%5s%14.4e%14.4e ; %s&#39;</span> % (i,M[i][0],M[i][1],0.0,<span class="stringliteral">&#39;A&#39;</span>,M[i][2],M[i][3],M[i][4])
<a name="l00864"></a>00864         <span class="keywordflow">else</span>:
<a name="l00865"></a>00865             Orthodox = 1
<a name="l00866"></a>00866             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; %s&#39;</span> % (i,BAT[i],M[i][0],M[i][1],0.0,<span class="stringliteral">&#39;A&#39;</span>,M[i][2],M[i][3],M[i][4])
<a name="l00867"></a>00867     choice = raw_input(<span class="stringliteral">&quot;Do you want to add atomtypes for a water model?? 0 for SPC(/E), 1 for TIP4P, anything else for No: --&gt;&quot;</span>)
<a name="l00868"></a>00868     <span class="keywordflow">try</span>:
<a name="l00869"></a>00869         choice = int(choice)
<a name="l00870"></a>00870         <span class="keywordflow">if</span> choice == 0:
<a name="l00871"></a>00871             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; SPC/E Oxygen&#39;</span> % (<span class="stringliteral">&quot;opls_116&quot;</span>,<span class="stringliteral">&quot;OW&quot;</span>,8,15.99940,-0.820,<span class="stringliteral">&quot;A&quot;</span>,3.16557e-01,6.50194e-01)
<a name="l00872"></a>00872             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; SPC/E Hydrogen&#39;</span> % (<span class="stringliteral">&quot;opls_117&quot;</span>,<span class="stringliteral">&quot;HW&quot;</span>,1,1.00800,0.410,<span class="stringliteral">&quot;A&quot;</span>,0.00000e+00,0.00000e+00)
<a name="l00873"></a>00873         <span class="keywordflow">elif</span> choice == 1:
<a name="l00874"></a>00874             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; TIP4P Oxygen&#39;</span> % (<span class="stringliteral">&quot;opls_113&quot;</span>,<span class="stringliteral">&quot;OW&quot;</span>,8,15.99940,0.000,<span class="stringliteral">&quot;A&quot;</span>,3.15365e-01,6.48520e-01)
<a name="l00875"></a>00875             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; TIP4P Hydrogen&#39;</span> % (<span class="stringliteral">&quot;opls_114&quot;</span>,<span class="stringliteral">&quot;HW&quot;</span>,1,1.00800,0.520,<span class="stringliteral">&quot;A&quot;</span>,0.00000e+00,0.00000e+00)
<a name="l00876"></a>00876             <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5s%5i%10.4f%10.4f%5s%14.4e%14.4e ; TIP4P Virtual Site&#39;</span> % (<span class="stringliteral">&quot;opls_115&quot;</span>,<span class="stringliteral">&quot;MW&quot;</span>,0,0.00000,-1.040,<span class="stringliteral">&quot;D&quot;</span>,0.00000e+00,0.00000e+00)
<a name="l00877"></a>00877         <span class="keywordflow">else</span>:
<a name="l00878"></a>00878             <span class="keywordflow">pass</span>
<a name="l00879"></a>00879     <span class="keywordflow">except</span>: <span class="keywordflow">pass</span>
<a name="l00880"></a>00880     <span class="keywordflow">print</span> &gt;&gt; itpfile
<a name="l00881"></a>00881     <span class="comment"># Prints parameter type definitions for bonds, angles, dihedrals.</span>
<a name="l00882"></a>00882     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintTypeSection(<span class="stringliteral">&quot;bondtypes&quot;</span>,BondTypes):
<a name="l00883"></a>00883         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00884"></a>00884     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintTypeSection(<span class="stringliteral">&quot;angletypes&quot;</span>,AngleTypes):
<a name="l00885"></a>00885         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00886"></a>00886     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintTypeSection(<span class="stringliteral">&quot;dihedraltypes&quot;</span>,DihedralTypes):
<a name="l00887"></a>00887         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00888"></a>00888     <span class="comment"># Prints moleculetype.</span>
<a name="l00889"></a>00889     <span class="keywordflow">print</span> &gt;&gt; itpfile
<a name="l00890"></a>00890     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;[ moleculetype ]&#39;</span>
<a name="l00891"></a>00891     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%-10s%5i&#39;</span> % (molname,3) <span class="comment"># Number of exclusions</span>
<a name="l00892"></a>00892     <span class="keywordflow">print</span> &gt;&gt; itpfile
<a name="l00893"></a>00893     <span class="comment"># Prints atoms.</span>
<a name="l00894"></a>00894     <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;[ atoms ]&#39;</span>
<a name="l00895"></a>00895     SumCharges = 0.0
<a name="l00896"></a>00896     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00897"></a>00897         <span class="comment"># atom = BAT[T[i]] + &quot;%i&quot; % (i+1)</span>
<a name="l00898"></a>00898         atom = E[i] + <span class="stringliteral">&quot;%i&quot;</span> % (i+1)
<a name="l00899"></a>00899         <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&#39;%5i%10s%5i%10s%7s%5i%10.4f%10.4f&#39;</span> % (i+1,T[i],1,molname,atom,i+1,QDict[T[i]],M[T[i]][1])
<a name="l00900"></a>00900         SumCharges += QDict[T[i]]
<a name="l00901"></a>00901     <span class="keywordflow">if</span> abs(SumCharges) &gt; 1e-6:
<a name="l00902"></a>00902         <span class="keywordflow">print</span> &gt;&gt; itpfile, <span class="stringliteral">&quot;; The total charge of the generated FF is %.4f.&quot;</span> % SumCharges
<a name="l00903"></a>00903     <span class="keywordflow">print</span> &gt;&gt; itpfile
<a name="l00904"></a>00904     <span class="comment"># Prints atom lists for bonds, angles, dihedrals.</span>
<a name="l00905"></a>00905     choice = raw_input(<span class="stringliteral">&quot;Print structural bond lengths into force field file? --&gt;&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00906"></a>00906     <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00907"></a>00907         PrintBaseVals = 1
<a name="l00908"></a>00908     <span class="keywordflow">else</span>:
<a name="l00909"></a>00909         PrintBaseVals = 0
<a name="l00910"></a>00910     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintItemSection(<span class="stringliteral">&quot;bonds&quot;</span>,BondTypes,BList,PrintBaseVals,0):
<a name="l00911"></a>00911         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00912"></a>00912     choice = raw_input(<span class="stringliteral">&quot;Print structural angles into force field file? (Enter no for sub180.) --&gt;&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00913"></a>00913     Sub180 = 0
<a name="l00914"></a>00914     <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00915"></a>00915         PrintBaseVals = 1
<a name="l00916"></a>00916     <span class="keywordflow">else</span>:
<a name="l00917"></a>00917         PrintBaseVals = 0
<a name="l00918"></a>00918         choice = raw_input(<span class="stringliteral">&quot;Try to substitute alternate parameters for linear angles (threshold is 150 degrees)? --&gt;&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00919"></a>00919         <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00920"></a>00920             Sub180 = 1
<a name="l00921"></a>00921     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintItemSection(<span class="stringliteral">&quot;angles&quot;</span>,AngleTypes,AList,PrintBaseVals,Sub180):
<a name="l00922"></a>00922         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00923"></a>00923     PrintBaseVals = 0
<a name="l00924"></a>00924     <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintItemSection(<span class="stringliteral">&quot;dihedrals&quot;</span>,DihedralTypes,DList,0,0):
<a name="l00925"></a>00925         <span class="keywordflow">print</span> &gt;&gt; itpfile, line
<a name="l00926"></a>00926     choice = raw_input(<span class="stringliteral">&quot;Print 1-4 pairs into force field file? (Seems the only way to make 1-4 interactions work.) --&gt;&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>
<a name="l00927"></a>00927     <span class="keywordflow">if</span> <span class="stringliteral">&#39;y&#39;</span> == choice[0] <span class="keywordflow">or</span> <span class="stringliteral">&#39;Y&#39;</span> == choice[0]:
<a name="l00928"></a>00928         <span class="keywordflow">for</span> line <span class="keywordflow">in</span> PrintPairs(BList,DList):
<a name="l00929"></a>00929             <span class="keywordflow">print</span> &gt;&gt; itpfile,line
<a name="l00930"></a>00930     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Parameter file written to %s&quot;</span> % (argv[1].replace(<span class="stringliteral">&#39;.com&#39;</span>,<span class="stringliteral">&#39;.itp&#39;</span>))
<a name="l00931"></a>00931     itpfile.close()
<a name="l00932"></a>00932 
<a name="l00933"></a>00933 <span class="keyword">def </span>printgro():
<a name="l00934"></a>00934     grofile = open(argv[1].replace(<span class="stringliteral">&#39;.com&#39;</span>,<span class="stringliteral">&#39;.gro&#39;</span>),<span class="stringliteral">&#39;w&#39;</span>)
<a name="l00935"></a>00935     <span class="keywordflow">print</span> &gt;&gt; grofile, <span class="stringliteral">&#39;Generated by gauss2gro: %s&#39;</span> % molname
<a name="l00936"></a>00936     <span class="keywordflow">print</span> &gt;&gt; grofile, na
<a name="l00937"></a>00937     res = <span class="stringliteral">&quot;1&quot;</span>+molname
<a name="l00938"></a>00938     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(na):
<a name="l00939"></a>00939         <span class="comment">#atom = BAT[T[i]] + &quot;%i&quot; % (i+1)</span>
<a name="l00940"></a>00940         atom = E[i] + <span class="stringliteral">&quot;%i&quot;</span> % (i+1)
<a name="l00941"></a>00941         <span class="keywordflow">print</span> &gt;&gt; grofile, <span class="stringliteral">&quot;%8s%7s%5i%12.7f%12.7f%12.7f&quot;</span> % (res,atom,i+1,R[i][0],R[i][1],R[i][2])
<a name="l00942"></a>00942     <span class="keywordflow">print</span> &gt;&gt; grofile, <span class="stringliteral">&quot;   3.00000   3.00000   3.00000&quot;</span>
<a name="l00943"></a>00943     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Coordinate file written to %s&quot;</span> % (argv[1].replace(<span class="stringliteral">&#39;.com&#39;</span>,<span class="stringliteral">&#39;.gro&#39;</span>))
<a name="l00944"></a>00944     grofile.close()
<a name="l00945"></a>00945     
<a name="l00946"></a>00946 <span class="keyword">def </span>main():
<a name="l00947"></a>00947     printitp()
<a name="l00948"></a>00948     printgro()
<a name="l00949"></a>00949     <span class="keywordflow">print</span> <span class="stringliteral">&quot;Program Finished Successfully.  Have fun!&quot;</span>
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 main()
<a name="l00952"></a>00952 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 12 2013 09:41:24 for ForceBalance by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
